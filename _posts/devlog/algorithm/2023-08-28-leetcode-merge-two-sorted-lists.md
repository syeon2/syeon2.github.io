---
layout: post
title: "[LeetCode] 21. Merge Two Sorted Lists"
subtitle: "algorithm"
categories: devlog
tags: algorithm array linked-list
---

> LeetCode Top Interview 150ì˜ 21ë²ˆ ë¬¸ì œì…ë‹ˆë‹¤.

<!--more-->

ğŸ“š ëª©ì°¨
- [ğŸŒ± Merge Two Sorted Lists](#-merge-two-sorted-lists)
  - [ğŸŸ¤ ë¬¸ì œ ì •ì˜ - Definition](#-ë¬¸ì œ-ìš”ì•½-definition)
  - [ğŸŸ¤ ë¬¸ì œ í’€ì´ ì „ëµ ì¶”ìƒí™” - Abstraction](#-ë¬¸ì œ-í’€ì´-ì „ëµ-ì¶”ìƒí™”-abstraction)
  - [ğŸŸ¤ ë¬¸ì œ í’€ì´ - Algorithm](#-ë¬¸ì œ-í’€ì´-algorithm)

----

## ğŸŒ± [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/?envType=study-plan-v2&envId=top-interview-150)

### ğŸŸ¤ ë¬¸ì œ ì •ì˜ (Definition)

- íŒŒë¦¬ë¯¸í„°ë¡œ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡°ë¥¼ ê°€ì§„ ë…¸ë“œ 2ê°œê°€ ì£¼ì–´ì§„ë‹¤.
- í•´ë‹¹ ë…¸ë“œëŠ” int í•„ë“œë¥¼ ê°€ì§€ê³  ìˆë‹¤.

- íŒŒë¼ë¯¸í„°ë¡œ ì£¼ì–´ì§„ 2ê°œì˜ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ëŠ” headì˜ ì—­í• ì„ í•˜ë©° child ë…¸ë“œë¥¼ ê°€ì§€ê³  ìˆë‹¤.
- ê°ì ì—°ê²°ë˜ì–´ ìˆëŠ” ë…¸ë“œì˜ í•„ë“œê°’ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¥ë ¬í•˜ì—¬ í•˜ë‚˜ì˜ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡° í˜•íƒœë¡œ ì¬êµ¬ì„±í•˜ëŠ” ë¬¸ì œì´ë‹¤.


- ì¡°ê±´
  - The number of nodes in both lists is in the range [0, 50].
  - -100 <= Node.val <= 100
  - Both list1 and list2 are sorted in non-decreasing order.

---

### ğŸŸ¤ ë¬¸ì œ í’€ì´ ì „ëµ ì¶”ìƒí™” (Abstraction)

ì´ ë¬¸ì œì˜ ê²½ìš° ë§¤ìš° ê°„ë‹¨í•˜ê²Œ í’€ ìˆ˜ ìˆë‹¤. ë°°ì—´ì´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆëŠ” ê²ƒì²˜ëŸ¼ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ê°€ ì˜¤ë¦„ì°¨ìˆœ í•„ë“œë¥¼ ê°€ì§€ëŠ” ìˆœì„œë¡œ 
ìì‹ ë…¸ë“œì— í• ë‹¹ë˜ì–´ ìˆë‹¤ëŠ” ê²ƒì„ íŒŒì•…í•˜ë©´ ëœë‹¤.

ë¨¼ì €, headê°€ ë  ë…¸ë“œë¥¼ í•˜ë‚˜ ìƒì„±í•œë‹¤. ì´ í—¤ë“œì˜ ë…¸ë“œë¡œë¶€í„° ìì‹ë…¸ë“œê°€ ë  ë…¸ë“œë¥¼ ì°¾ì•„ì•¼í•˜ëŠ”ë°, 2ê°œì˜ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ì˜ í˜„ì¬ val í•„ë“œê°’ì„ 
ë¹„êµí•˜ì—¬ ì‘ì€ ê°’ì„ ê°€ì§„ ë…¸ë“œë¥¼ í—¤ë“œì˜ next í•„ë“œì— ì´ˆê¸°í™”í•œë‹¤. ê·¸ë¦¬ê³  ì´ˆê¸°í™”í•œ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ì˜ ë³€ìˆ˜ë¥¼ ìì‹ ë…¸ë“œë¡œ ì´ˆê¸°í™”í•œë‹¤.

ì´ëŸ° ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì€ ë§ˆì¹˜ ë°°ì—´ì˜ ì¸ë±ìŠ¤ê°€ ë¹„êµ í›„ 1ì”© ì¦ê°€í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ ë™ì‘í•œë‹¤. í˜„ì¬ì˜ ë…¸ë“œë¥¼ ë¹„êµ ì™„ë£Œí•˜ì—¬ í• ë‹¹í•˜ë©´ 
í•´ë‹¹ ë…¸ë“œì—ì„œ ë‹¤ìŒ ë…¸ë“œë¡œ ê°±ì‹ í•´ì•¼ ë˜ë‹¤ì‹œ ë¹„êµí•  ìˆ˜ ìˆëŠ” ì›ë¦¬ì´ë‹¤.

> ğŸ¥• ì‹œê°„ë³µì¡ë„ë¡œëŠ” 2ê°œì˜ ë…¸ë“œë¥¼ íˆ¬í¬ì¸í„° ë°©ì‹ìœ¼ë¡œ ìˆœì„œëŒ€ë¡œ ìˆœí™˜í•˜ê¸° ë•Œë¬¸ì— O(2N) => O(N)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.
> 
> ğŸ¥• ê³µê°„ë³µì¡ë„ëŠ” ë§í¬ë“œë¦¬ìŠ¤íŠ¸ ë…¸ë“œì˜ íŠ¹ì„±ì— ë”°ë¼ ë³„ë„ë¡œ ì¶”ê°€ëœ ê³µê°„ì€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ O(1)ì˜ ê³µê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.


> í•´ë‹¹ ë¬¸ì œëŠ” ì™œ ê³µê°„ë³µì¡ë„ O(1)ì„ ê°€ì§ˆê¹Œ?
> 
> ë°°ì—´ê³¼ í–‡ê°ˆë¦¬ëŠ” ë¶€ë¶„ì´ë‹¤. ë°°ì—´ì€ ì„ ì–¸í•˜ê²Œ ë˜ë©´ ì—°ì†ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ ê³µê°„ì„ í• ë‹¹í•œë‹¤. í• ë‹¹ëœ ë©”ëª¨ë¦¬ ê³µê°„ ì•ˆì—ì„œ ê° ê°’ë“¤ì´ ì°¸ì¡°ë˜ëŠ” ë°©ì‹ì´ê¸° ë•Œë¬¸ì— 
> Në§Œí¼ì˜ ê¸¸ì´ë¥¼ ê°€ì§€ëŠ” ë°°ì—´ì€ Në§Œí¼ì˜ ê³µê°„ì„ ìƒˆë¡œ ë§Œë“ ë‹¤.
> 
> ë°˜ë©´ì— ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ëŠ” ì°¸ì¡° íƒ€ì… ë°ì´í„°ì˜ ì—°ì†ì´ë‹¤. ì°¸ì¡° íƒ€ì… ë°ì´í„°ëŠ” Heapì´ë¼ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì— í• ë‹¹ë˜ëŠ”ë°, ì´ëŸ° ì°¸ì¡° íƒ€ì… ë°ì´í„°ì˜ 
> íŠ¹ì§•ì€ deep copyë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ í•´ë‹¹ ì°¸ì¡° ë°ì´í„°ë¥¼ ë‹¤ë¥¸ ë³€ìˆ˜ê°€ ì°¸ì¡°í•  ìˆ˜ ìˆë‹¤.
> 
> ì˜ˆë¥¼ ë“¤ì–´, <br />
> int a = 10; <br />
> b = a; <br />
> ê°™ì´ ê¸°ë³¸ íƒ€ì… ë°ì´í„°ëŠ” aë¥¼ 20ìœ¼ë¡œ ì¬í• ë‹¹í•´ë„ bëŠ” 10ì„ ê°€ì§€ê³  ìˆë‹¤. ì¦‰, ê¸°ë³¸ íƒ€ì… ë°ì´í„°ëŠ” í• ë‹¹í•  ë•Œ í•´ë‹¹ ê°’ìœ¼ë¡œ ì°¸ì¡°ëœë‹¤. (ì •í™•í•˜ê²ŒëŠ” 
> JVM Stack ë©”ëª¨ë¦¬ì— ì§ì ‘ ì €ì¥ë˜ê³ , ì¸ìŠ¤í„´ìŠ¤ì˜ í•„ë“œë¡œì¨ ì €ì¥ë  ë•ŒëŠ” Heap ì˜ì—­ì— ì§ì ‘ ì €ì¥ëœë‹¤. ê¸°ë³¸íƒ€ì… ë°ì´í„°ë¥¼ í• ë‹¹í•˜ê±°ë‚˜ ë¹„êµí•  ë•ŒëŠ” ê°’ìœ¼ë¡œ 
> íŒë‹¨í•œë‹¤.)
> 
> ì°¸ì¡° íƒ€ì… ë°ì´í„°ëŠ” ì¡°ê¸ˆ ë‹¤ë¥´ê²Œ ë™ì‘í•œë‹¤. <br />
> Node a = new Node(1); <br />
> Node b = a; <br />
> 
> a.val = 3; <br />
> b.val == 3 => true <br />
> 
> ì°¸ì¡° íƒ€ì… ë°ì´í„°ëŠ” ë³€ìˆ˜ì— í• ë‹¹ë  ë•Œ Heapì´ë¼ëŠ” ë°ì´í„° ì£¼ì†Œë¥¼ í• ë‹¹ë°›ëŠ”ë‹¤. bëŠ” aì˜ ë…¸ë“œë¥¼ í• ë‹¹ë°›ì•˜ëŠ”ë°, aì™€ bëŠ” ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ 
> í• ë‹¹ë°›ì•˜ë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. ë”°ë¼ì„œ ë™ì¼í•œ ì£¼ì†Œê°’ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— aì˜ ë…¸ë“œ í•„ë“œë¥¼ ë³€ê²½í•˜ë©´ bì—ë„ ì˜í–¥ì´ ë¼ì¹œë‹¤.

---

### ğŸŸ¤ ë¬¸ì œ í’€ì´ (Algorithm)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode answer = new ListNode(0);

        ListNode l1 = list1;
        ListNode l2 = list2;

        ListNode temp = answer;

        while (l1 != null && l2 != null) {
            int l1Val = l1.val;
            int l2Val = l2.val;

            if (l1Val < l2Val) {
                temp.next = l1;
                temp = l1;
                l1 = l1.next;
            } else {
                temp.next = l2;
                temp = l2;
                l2 = l2.next;
            }
        }

        if (l1 != null && l2 == null) {
            while (l1 != null) {
                temp.next = l1;
                temp = l1;
                l1 = l1.next;
            }
        } else if (l1 == null && l2 != null) {
            while (l2 != null) {
                temp.next = l2;
                temp = l2;
                l2 = l2.next;
            }
        }

        answer = answer.next;

        return answer;
    }
}
```

---
