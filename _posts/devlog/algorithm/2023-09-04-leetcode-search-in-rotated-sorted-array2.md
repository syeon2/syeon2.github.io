---
layout: post
title: "[LeetCode] 33. Search in Rotated Sorted Array"
subtitle: "algorithm"
categories: devlog
tags: algorithm binary-search
---

> LeetCode Top Interview 150ì˜ 33ë²ˆ ë¬¸ì œì…ë‹ˆë‹¤.

<!--more-->

ğŸ“š ëª©ì°¨
- [ğŸŒ± Search in Rotated Sorted Array](#-search-in-rotated-sorted-array)
  - [ğŸŸ¤ ë¬¸ì œ ì •ì˜ - Definition](#-ë¬¸ì œ-ìš”ì•½-definition)
  - [ğŸŸ¤ ë¬¸ì œ í’€ì´ ì „ëµ ì¶”ìƒí™” - Abstraction](#-ë¬¸ì œ-í’€ì´-ì „ëµ-ì¶”ìƒí™”-abstraction)
  - [ğŸŸ¤ ë¬¸ì œ í’€ì´ - Algorithm](#-ë¬¸ì œ-í’€ì´-algorithm)

----

## ğŸŒ± [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150)

### ğŸŸ¤ ë¬¸ì œ ì •ì˜ (Definition)

- íŒŒë¼ë¯¸í„°ë¡œ 1ì°¨ì› ë°°ì—´ (nums)ì™€ ëª©í‘œê°’(target)ì´ ì£¼ì–´ì§„ë‹¤.
- ë³¸ë˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆëŠ” ë°°ì—´ì„ ì¸ë±ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ íšŒì „ì‹œí‚¨ ë°°ì—´ì´ numsì´ë‹¤.
- íšŒì „ì´ë¼ í•¨ì€ [0, 1, 2, 3]ì´ë¼ëŠ” ë°°ì—´ì´ ìˆë‹¤ë©´, ì™¼ìª½ìœ¼ë¡œ 2 íšŒì „ì‹œì¼œ [2, 3, 0, 1]ë¡œ ë§Œë“  ë°°ì—´ì´ë¼ëŠ” ì˜ë¯¸ì´ë‹¤.
- ìœ„ì™€ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§„ numsì—ì„œ targetì„ ì°¾ëŠ”ë° targetì´ ìˆë‹¤ë©´ targetì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ë¥¼ ë°˜í™˜í•˜ê³  ì—†ë‹¤ë©´ -1ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì´ë‹¤.


- ì¡°ê±´
  - 1 <= nums.length <= 5000
  - -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>
  - All values of nums are unique.
  - nums is an ascending array that is possibly rotated.
  - -10<sup>4</sup> <= target <= 10<sup>4</sup>

---

### ğŸŸ¤ ë¬¸ì œ í’€ì´ ì „ëµ ì¶”ìƒí™” (Abstraction)

ë°©ë²• 1.
ì•„ì£¼ ê°„ë‹¨í•œ ë°©ë²•ìœ¼ë¡œ O(N)ìœ¼ë¡œ ìˆœí™˜í•˜ë©´ì„œ targetê°’ì´ ìˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤.


ë°©ë²• 2.
í•˜ì§€ë§Œ ì´ë²ˆ ë¬¸ì œì—ì„œë„ O(logN)ì˜ ì‹œê°„ë³µì¡ë„ë¡œ ë¬¸ì œë¥¼ í’€ë„ë¡ í•œë‹¤. ì´ë²ˆì—ëŠ” ì—­ìœ¼ë¡œ ì‚¬ê³ í•´ì•¼í•œë‹¤.

ì´ë²ˆ ë¬¸ì œë„ O(logN)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ì´ì§„ íƒìƒ‰ì„ ì‚¬ìš©í•œë‹¤. ì´ì§„íƒìƒ‰ê³¼ í•´ë‹¹ ë¬¸ì œë¥¼
í•´ê²°í•˜ê¸° ìœ„í•œ ë¬¸ì œ í•´ê²° ë°©ë²•ì„ ì ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

ë¬¸ì œì—ì„œ ì£¼ì–´ì§€ëŠ” ë°°ì—´ì€ ì˜¤ë¦„ì°¨ìˆœ 1ì°¨ì› ë°°ì—´ì´ì—ˆì§€ë§Œ, ì–´ëŠ í•œ ì§€ì ì—ì„œ íšŒì „í•˜ì˜€ê¸° ë•Œë¬¸ì— ì™„ë²½í•œ ì˜¤ë¦„ì°¨ìˆœì€ ì•„ë‹ˆë‹¤. í•˜ì§€ë§Œ í•œêµ¬ê°„ì„ ì œì™¸í•˜ê³ ëŠ”
ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— ì´ íŠ¹ì§•ì„ ì´ìš©í•´ì•¼í•œë‹¤.

ë¨¼ì € ê°€ìš´ë° ê°’ì„ ë¹„êµí•˜ì—¬ í•´ë‹¹ ê°’ì´ë©´ ê·¸ëŒ€ë¡œ ê°€ìš´ë°ê°’ì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ë©´ ëœë‹¤. í•˜ì§€ë§Œ ê°€ìš´ë°ê°’ì´ ëª©í‘œê°’ì´ ì•„ë‹ˆë¼ë©´ ì„ íƒì§€ê°€ 2ê°œë¡œ ë‚˜ë‰œë‹¤.
ì¸ë±ìŠ¤ midë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì„ ëª©í‘œê°’ê³¼ ë¹„êµí•˜ëŠ” ê²ƒì´ë‹¤. ë°°ì—´ ì¤‘ ì–´ëŠ í•œêµ¬ê°„ë§Œ ì˜¤ë¦„ì°¨ìˆœì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ì™¼ìª½ ì˜¤ë¥¸ìª½ ë‘˜ì¤‘ í•œ êµ¬ê°„ì€ ì˜¤ë¦„ì°¨ìˆœì´ë‹¤.
ë§Œì¼ ëª©í‘œê°’ì´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë˜ì–´ ìˆëŠ” êµ¬ê°„ ì•ˆì— í¬í•¨ë˜ì–´ ìˆëŠ” ê°’ì´ë¼ë©´ í•´ë‹¹ êµ¬ê°„ì—ì„œ ì´ì§„íƒìƒ‰í•˜ë©´ ëœë‹¤. í•˜ì§€ë§Œ, ëª©í‘œê°’ì´ ê·¸ êµ¬ê°„ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ìì—°ìŠ¤ëŸ½ê²Œ
ë‚˜ë¨¸ì§€ êµ¬ê°„ ì•ˆì— ëª©í‘œê°’ì´ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ [4, 5, 6, 7, 1] ì¤‘ ëª©í‘œê°’ì€ 7ì´ë¼ê³  í•œë‹¤ë©´, 6ì„ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì„ ë¹„êµí•œë‹¤. ì™¼ìª½ì€ 4, 5ë¡œ ì •ë ¬ë˜ì–´ ìˆì§€ë§Œ 7ì€ 4, 5ì˜ ë²”ìœ„ ì•ˆì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ”ë‹¤.
ë”°ëŸ¬ì„œ 6ì˜ ì˜¤ë¥¸ìª½ì€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆì§€ëŠ” ì•Šì§€ë§Œ ëª©í‘œê°’ì„ ê°€ì§€ê³  ìˆëŠ” ë°¤ìœ„ë¼ëŠ” ì˜ë¯¸ê°€ ëœë‹¤. ê·¸ëŸ¼ ì˜¤ë¥¸ìª½ ë²”ìœ„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ì´ì§„íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.

ì´ ë°©ë²•ì„ ë°˜ë³µí•˜ë©´ ê°’ì„ ì°¾ì„ ìˆ˜ ìˆìœ¼ë©°, í•´ë‹¹ê°’ì´ ì—†ëŠ” ê²½ìš° -1ì„ ë°˜í™˜í•œë‹¤.

> ğŸ¥• ì‹œê°„ë³µì¡ë„ë¡œëŠ” O(logN)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.
>
> ğŸ¥• ê³µê°„ë³µì¡ë„ëŠ” ì¬ê·€ Stackì´ ìƒì„±ë˜ê¸° ë•Œë¬¸ì— O(logN)ì˜ ê³µê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.

---

### ğŸŸ¤ ë¬¸ì œ í’€ì´ (Algorithm)

ë°©ë²• 1.
```java
class Solution {
    public int search(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) return i;
        }

        return -1;
    }
}
```

ë°©ë²• 2.

```java
class Solution {
    public int search(int[] nums, int target) {
        return binarySearch(nums, 0, nums.length - 1, target);
    }

    public int binarySearch(int[] list, int start, int end, int target) {
        if (start == end) {
            if (list[start] == target) return start;
            else return -1;
        }

        int mid = (start + end) / 2;

        if (list[mid] == target) return mid;


        if (list[mid] >= list[start]) {
            if (list[start] <= target && list[mid] > target) {
                return binarySearch(list, 0, mid - 1, target);
            } else {
                return binarySearch(list, mid + 1, end, target);
            }
        } else {
            if (list[mid] < target && list[end] >= target) {
                return binarySearch(list, mid + 1, end, target);
            } else {
                return binarySearch(list, 0, mid - 1, target);
            }
        }
    }
}
```

---
